arm.h	arm.c
CPU的关键寄存器、工作模式、初始化、中断、指令执行的抽象，内存的读写操作的抽象等
ARMRun()->ARMStep()->

macros.h
数据加载与读取相关的宏（函数）

isa-inlines.h
ARM和Thumb模式下的共同的操作的静态内联函数

isa-arm.h	isa-arm.c
ARM模式下所有指令的定义和实现

isa-thumb.h  isa-thumb.c
THUMB模式下所有指令的定义和实现

decoder-inlines.h  decoder.h  decoder.c  decoder-arm.c  decoder-thumb.c
反汇编，解码二进制机器码，提取32位二进制机器码的信息

emitter-inlines.h  emitter-arm.h  emitter-thumb.h
所有指令的宏定义，DECLARE_ARM_EMITTER_BLOCK(EMITTER)，DECLARE_THUMB_EMITTER_BLOCK




ARM指令反汇编：解码二进制机器码，提取32位二进制机器码的信息
decoder.h
struct ARMInstructionInfo {		//保存指令信息：将32位二进制机器码的信息提取到该结构体
	uint32_t opcode;
	union ARMOperand op1;
	union ARMOperand op2;
	union ARMOperand op3;
	union ARMOperand op4;
	struct ARMMemoryAccess memory;
	int operandFormat;
	unsigned execMode : 1;
	bool traps : 1;
	bool affectsCPSR : 1;
	unsigned branchType : 3;
	unsigned condition : 4;
	unsigned mnemonic : 6;
	unsigned iCycles : 3;
	unsigned cCycles : 4;
	unsigned sInstructionCycles : 4;
	unsigned nInstructionCycles : 4;
	unsigned sDataCycles : 10;
	unsigned nDataCycles : 10;
};
void ARMDecodeARM(uint32_t opcode, struct ARMInstructionInfo* info);
void ARMDecodeThumb(uint16_t opcode, struct ARMInstructionInfo* info);
int **ARMDisassemble**(struct ARMInstructionInfo* info, uint32_t pc, char* buffer, int blen);

decoder-arm.c
typedef void (*ARMDecoder)(uint32_t opcode, struct ARMInstructionInfo* info);

static const ARMDecoder _armDecoderTable[0x1000] = {
	DECLARE_ARM_EMITTER_BLOCK(_ARMDecode)
};

DECLARE_ARM_EMITTER_BLOCK(_ARMDecode)
扩展为：
    ......
    _ARMDecodeADD_LSL
	_ARMDecodeADD_LSLR
	_ARMDecodeADD_LSR
	_ARMDecodeADD_LSRR
	_ARMDecodeADD_ASR
	_ARMDecodeADD_ASRR
	_ARMDecodeADD_ROR
	_ARMDecodeADD_RORR
	_ARMDecodeADD_LSL
	_ARMDecodeUMULL
	_ARMDecodeADD_LSR
	_ARMDecodeSTRHU
	_ARMDecodeADD_ASR
	_ARMDecodeILL
	_ARMDecodeADD_ROR
	_ARMDecodeILL
    ......

static void _ARMDecode ## ADD ## _LSL (uint32_t opcode, struct ARMInstructionInfo* info) { \
		UNUSED(opcode); \
		info->mnemonic = ARM_MN_ ## ADD; \
		
		info->op1.reg = (opcode >> 12) & 0xF; \
		info->op2.reg = (opcode >> 16) & 0xF; \
		info->operandFormat = ARM_OPERAND_REGISTER_1 | \
			ARM_OPERAND_AFFECTED_1 | \
			ARM_OPERAND_REGISTER_2; \
		info->affectsCPSR = 0; \
		ADDR_MODE_1_LSL; \
		if (0 == 1) { \
			info->operandFormat >>= 8; \
			info->op1 = info->op2; \
			info->op2 = info->op3; \
		} else if (0 == 2) { \
			info->operandFormat &= ~ARM_OPERAND_2; \
		} \
		if (info->op1.reg == ARM_PC) { \
			info->branchType = ARM_BRANCH_INDIRECT; \
		}; \
	}

void ARMDecodeARM(uint32_t opcode, struct ARMInstructionInfo* info) {
	info->execMode = MODE_ARM;
	info->opcode = opcode;
	info->branchType = ARM_BRANCH_NONE;
	info->traps = 0;
	info->affectsCPSR = 0;
	info->condition = opcode >> 28;
	info->sDataCycles = 0;
	info->nDataCycles = 0;
	info->sInstructionCycles = 1;
	info->nInstructionCycles = 0;
	info->iCycles = 0;
	info->cCycles = 0;
	ARMDecoder decoder = _armDecoderTable[((opcode >> 16) & 0xFF0) | ((opcode >> 4) & 0x00F)];
	decoder(opcode, info);
}




ARM指令定义：
isa-arm.h
typedef void (*ARMInstruction)(struct ARMCore*, uint32_t opcode);
const ARMInstruction _armTable[0x1000];

isa-arm.c
const ARMInstruction _armTable[0x1000] = {
	DECLARE_ARM_EMITTER_BLOCK(_ARMInstruction)
};

DECLARE_ARM_EMITTER_BLOCK(_ARMInstruction)
扩展为：
    ......
    _ARMInstructionADD_LSL
	_ARMInstructionADD_LSLR
	_ARMInstructionADD_LSR
	_ARMInstructionADD_LSRR
	_ARMInstructionADD_ASR
	_ARMInstructionADD_ASRR
	_ARMInstructionADD_ROR
	_ARMInstructionADD_RORR
	_ARMInstructionADD_LSL
	_ARMInstructionUMULL
	_ARMInstructionADD_LSR
	_ARMInstructionSTRHU
	_ARMInstructionADD_ASR
	_ARMInstructionILL
	_ARMInstructionADD_ROR
	_ARMInstructionILL
    ......

具体执行的指令函数：
isa-arm.c
static void _ARMInstruction ## ADD ## _LSL (struct ARMCore* cpu, uint32_t opcode) {
		int currentCycles = ARM_PREFETCH_CYCLES;
		int rd = (opcode >> 12) & 0xF;
		int rn = (opcode >> 16) & 0xF;
		UNUSED(rn);
		_shiftLSL(cpu, opcode);
		int32_t n = cpu->gprs[rn]; 
		cpu->gprs[rd] = n + cpu->shifterOperand;;
		;
		if (rd == ARM_PC) {		//取指
			if (cpu->executionMode == MODE_ARM) {
				ARM_WRITE_PC;
			} else {
				THUMB_WRITE_PC;
			}
		}
		cpu->cycles += currentCycles;
	}




CPU重置：工作模式进入SYS模式，准备开始执行指令
void ARMReset(struct ARMCore* cpu) {
	int i;
	for (i = 0; i < 16; ++i) {
		cpu->gprs[i] = 0;
	}
	for (i = 0; i < 6; ++i) {
		cpu->bankedRegisters[i][0] = 0;
		cpu->bankedRegisters[i][1] = 0;
		cpu->bankedRegisters[i][2] = 0;
		cpu->bankedRegisters[i][3] = 0;
		cpu->bankedRegisters[i][4] = 0;
		cpu->bankedRegisters[i][5] = 0;
		cpu->bankedRegisters[i][6] = 0;
		cpu->bankedSPSRs[i] = 0;
	}

	cpu->privilegeMode = MODE_SYSTEM;
	cpu->cpsr.packed = MODE_SYSTEM;
	cpu->spsr.packed = 0;

	cpu->shifterOperand = 0;
	cpu->shifterCarryOut = 0;

	cpu->executionMode = MODE_THUMB;
	_ARMSetMode(cpu, MODE_ARM);		//设置CPU工作状态

	int currentCycles = 0;
	ARM_WRITE_PC;		//写ARM程序计数器

	cpu->cycles = 0;
	cpu->nextEvent = 0;
	cpu->halted = 0;

	cpu->irqh.reset(cpu);
}

//写ARM指令所用的程序计数器
#define ARM_WRITE_PC \
	cpu->gprs[ARM_PC] = (cpu->gprs[ARM_PC] & -WORD_SIZE_ARM); \
	cpu->memory.setActiveRegion(cpu, cpu->gprs[ARM_PC]); \
	LOAD_32(cpu->prefetch, cpu->gprs[ARM_PC] & cpu->memory.activeMask, cpu->memory.activeRegion); \
	cpu->gprs[ARM_PC] += WORD_SIZE_ARM; \
	currentCycles += 2 + cpu->memory.activeUncachedCycles32 + cpu->memory.activeSeqCycles32;

//写THUMB指令所用的程序计数器
#define THUMB_WRITE_PC \
	cpu->gprs[ARM_PC] = (cpu->gprs[ARM_PC] & -WORD_SIZE_THUMB); \
	cpu->memory.setActiveRegion(cpu, cpu->gprs[ARM_PC]); \
	LOAD_16(cpu->prefetch, cpu->gprs[ARM_PC] & cpu->memory.activeMask, cpu->memory.activeRegion); \
	cpu->gprs[ARM_PC] += WORD_SIZE_THUMB; \
	currentCycles += 2 + cpu->memory.activeUncachedCycles16 + cpu->memory.activeSeqCycles16;

cpu->memory.setActiveRegion(cpu, cpu->gprs[ARM_PC])-->static void GBASetActiveRegion(struct ARMCore* cpu, uint32_t address)...
该函数调用会设置cpu->memory.activeRegion、cpu->memory.activeMask

LOAD_32(cpu->prefetch, cpu->gprs[ARM_PC] & cpu->memory.activeMask, cpu->memory.activeRegion);
扩展为：
cpu->prefetch = ((uint32_t*) cpu->memory.activeRegion)[(cpu->gprs[ARM_PC] & cpu->memory.activeMask) >> 2]




ARM指令的执行：预取二进制机器指令，根据指令翻译结果找到对应的C函数（指令函数）
arm.c
static inline void ARMStep(struct ARMCore* cpu) {	//ARM处理器指令执行步骤
	uint32_t opcode = cpu->prefetch;

	LOAD_32(cpu->prefetch, cpu->gprs[ARM_PC] & cpu->memory.activeMask, cpu->memory.activeRegion);
	//展开为：cpu->prefetch = ((uint32_t*) cpu->memory.activeRegion)[(cpu->gprs[ARM_PC] & cpu->memory.activeMask) >> 2]

	cpu->gprs[ARM_PC] += WORD_SIZE_ARM;

	unsigned condition = opcode >> 28;
	if (condition != 0xE) {
		bool conditionMet = false;
		switch (condition) {
		case 0x0:
			conditionMet = ARM_COND_EQ;
			break;
		case 0x1:
			conditionMet = ARM_COND_NE;
			break;
		case 0x2:
			conditionMet = ARM_COND_CS;
			break;
		case 0x3:
			conditionMet = ARM_COND_CC;
			break;
		case 0x4:
			conditionMet = ARM_COND_MI;
			break;
		case 0x5:
			conditionMet = ARM_COND_PL;
			break;
		case 0x6:
			conditionMet = ARM_COND_VS;
			break;
		case 0x7:
			conditionMet = ARM_COND_VC;
			break;
		case 0x8:
			conditionMet = ARM_COND_HI;
			break;
		case 0x9:
			conditionMet = ARM_COND_LS;
			break;
		case 0xA:
			conditionMet = ARM_COND_GE;
			break;
		case 0xB:
			conditionMet = ARM_COND_LT;
			break;
		case 0xC:
			conditionMet = ARM_COND_GT;
			break;
		case 0xD:
			conditionMet = ARM_COND_LE;
			break;
		default:
			break;
		}
		if (!conditionMet) {
			cpu->cycles += ARM_PREFETCH_CYCLES;
			return;
		}
	}
								 _armTable[ [27-25][24-21][20]0000  |  00000000[7-4] ] = _armTable[ [27-25][24-21][20][7-4] ]
	ARMInstruction instruction = _armTable[((opcode >> 16) & 0xFF0) | ((opcode >> 4) & 0x00F)];
	instruction(cpu, opcode);
}

//指令循环
void ARMRunLoop(struct ARMCore* cpu) {
	if (cpu->executionMode == MODE_THUMB) {
		while (cpu->cycles < cpu->nextEvent) {
			ThumbStep(cpu);
		}
	} else {
		while (cpu->cycles < cpu->nextEvent) {
			ARMStep(cpu);
		}
	}
	cpu->irqh.processEvents(cpu);
}