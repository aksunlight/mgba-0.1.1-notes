arm.h	arm.c
CPU的关键寄存器、工作模式、初始化、中断、指令执行的抽象，内存的读写操作的抽象
ARMRun()->ARMStep()->

macros.h
数据加载与读取相关的宏（函数）

isa-inlines.h
ARM和Thumb模式下的共同的操作的静态内联函数

isa-arm.h	isa-arm.c
ARM模式下指令的定义

isa-thumb.h  isa-thumb.c
THUMB模式下指令的定义

decoder-inlines.h  decoder.h  decoder.c  decoder-arm.c  decoder-thumb.c
解码指令

emitter-inlines.h  emitter-arm.h  emitter-thumb.h
产生CPU所有的指令（助记符）




ARM指令定义：
isa-arm.h
typedef void (*ARMInstruction)(struct ARMCore*, uint32_t opcode);
const ARMInstruction _armTable[0x1000];

isa-arm.c
const ARMInstruction _armTable[0x1000] = {
	DECLARE_ARM_EMITTER_BLOCK(_ARMInstruction)
};

emitter-arm.h
DECLARE_ARM_EMITTER_BLOCK(_ARMInstruction)
扩展为：
    ......
    _ARMInstructionADD_LSL
	_ARMInstructionADD_LSLR
	_ARMInstructionADD_LSR
	_ARMInstructionADD_LSRR
	_ARMInstructionADD_ASR
	_ARMInstructionADD_ASRR
	_ARMInstructionADD_ROR
	_ARMInstructionADD_RORR
	_ARMInstructionADD_LSL
	_ARMInstructionUMULL
	_ARMInstructionADD_LSR
	_ARMInstructionSTRHU
	_ARMInstructionADD_ASR
	_ARMInstructionILL
	_ARMInstructionADD_ROR
	_ARMInstructionILL
    ......

具体执行的指令函数：
isa-arm.h
static void _ARMInstruction ## ADD ## _LSL (struct ARMCore* cpu, uint32_t opcode) {
		int currentCycles = ARM_PREFETCH_CYCLES;
		int rd = (opcode >> 12) & 0xF;
		int rn = (opcode >> 16) & 0xF;
		UNUSED(rn);
		_shiftLSL(cpu, opcode);
		int32_t n = cpu->gprs[rn]; 
		cpu->gprs[rd] = n + cpu->shifterOperand;;
		;
		if (rd == ARM_PC) {
			if (cpu->executionMode == MODE_ARM) {
				ARM_WRITE_PC;
			} else {
				THUMB_WRITE_PC;
			}
		}
		cpu->cycles += currentCycles;
	}